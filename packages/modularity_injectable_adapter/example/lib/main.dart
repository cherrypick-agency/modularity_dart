import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';
import 'package:modularity_contracts/modularity_contracts.dart';
import 'package:modularity_core/modularity_core.dart';
import 'package:modularity_injectable_adapter/modularity_injectable_adapter.dart';

/// Pretend these functions were generated by `injectable`.
GetIt configureInternal(GetIt getIt,
    {String? environment, EnvironmentFilter? environmentFilter}) {
  void register<T>(T Function() builder, {Set<String> envs = const {}}) {
    final shouldRegister =
        environmentFilter == null || environmentFilter.canRegister(envs);
    if (shouldRegister) {
      getIt.registerSingleton<T>(builder());
    }
  }

  register<AuthRepository>(() => AuthRepositoryImpl());
  register<AuthService>(
    () => AuthService(getIt<AuthRepository>()),
    envs: {modularityExportEnv.name},
  );

  register<DashboardViewModel>(
    () => DashboardViewModel(getIt<AuthService>()),
    envs: {modularityExportEnv.name},
  );

  return getIt;
}

/// Export wiring uses the same generated function with an environment filter.
GetIt configureExports(GetIt getIt,
    {String? environment, EnvironmentFilter? environmentFilter}) {
  // Forward to the same implementation; the environment filter decides what gets registered.
  return configureInternal(
    getIt,
    environment: environment,
    environmentFilter: environmentFilter,
  );
}

/// Simple domain + service classes -----------------------------------------

abstract class AuthRepository {}

class AuthRepositoryImpl implements AuthRepository {}

class AuthService {
  final AuthRepository repository;

  AuthService(this.repository);

  String currentUser() => 'demo@modularity.dev';
}

class DashboardViewModel {
  final AuthService authService;

  DashboardViewModel(this.authService);

  String greet() => 'Hello ${authService.currentUser()}';
}

/// Modules wired with the injectable bridge ---------------------------------

class AuthModule extends Module {
  @override
  void binds(Binder i) {
    ModularityInjectableBridge.configureInternal(i, configureInternal);

    // Module-specific singletons can still be registered manually if needed.
  }

  @override
  void exports(Binder i) {
    ModularityInjectableBridge.configureExports(i, configureExports);
  }
}

class DashboardModule extends Module {
  @override
  List<Module> get imports => [AuthModule()];

  @override
  void binds(Binder i) {
    // Dashboard gets AuthService via imports, but can add additional privates.
    i.registerLazySingleton(
        () => DashboardController(i.get<DashboardViewModel>()));
  }
}

class DashboardController {
  final DashboardViewModel viewModel;

  DashboardController(this.viewModel);

  void render() => print(viewModel.greet());
}

/// Demo entrypoint ----------------------------------------------------------

Future<void> main() async {
  final registry = <Type, ModuleController>{};

  final dashboardController = ModuleController(
    DashboardModule(),
    binderFactory: const GetItBinderFactory(),
  );

  await dashboardController.initialize(registry);

  final dashboard = dashboardController.binder.get<DashboardController>();
  dashboard.render();

  print(
    (dashboardController.binder as GetItBinder)
        .debugGraph(includeImports: true),
  );
}

## Обзор модульности во Flutter/Dart и сравнение с нашим фреймворком

### Цель документа

- **Цель**: зафиксировать, как сообщество Dart/Flutter решает задачи модульности в больших приложениях, и сравнить эти подходы с нашим модульным фреймворком.
- **Фокус**: архитектура, управление зависимостями, инициализацией (Initialization Hell), временем жизни модулей и тестируемостью.

---

## Архитектура и принципы (текущая реализация)

- **Монорепозиторий + разделение на слои (Packages)**:
  - `contracts` — **Pure Dart** интерфейсы (`Module`, `Binder`, `Configurable`, `ModuleInterceptor`). Определяет контракт взаимодействия без реализации.
  - `core` — Реализация логики: `ModuleController` (state-machine), `GraphResolver` (разрешение зависимостей), `SimpleBinder` (DI).
  - `flutter` — Интеграция с UI: `ModuleScope`, `ModuleProvider`, `ModularityRoot`, управление жизненным циклом через `RouteObserver`.
  - `modularity_test` — Утилиты для unit-тестирования модулей (`testModule`, `TestBinder`).
  - `adapters` — Тонкие обёртки под конкретные роутеры (GoRouter, AutoRoute и т.п.).
  - `modularity_cli` — CLI для визуализации графа зависимостей (Graphviz).

- **Модуль как конечный автомат**:
  - `imports` — Зависимости от других модулей (DAG + топологическая сортировка).
  - `submodules` — Структурная композиция для статического анализа.
  - `binds` / `exports` — Приватные и публичные зависимости.
  - `onInit()` — Асинхронная инициализация (гарантированно после всех импортов).
  - `status` (`initial`, `loading`, `loaded`, `error`, `disposed`) — Формализованное состояние.
  - `Configurable<T>` — Типизированная передача параметров (например, id из роута).
  - `hotReload(Binder)` — Хук для обновления фабрик без потери состояния синглтонов.

- **Строгий DI**:
  - Сервис‑локатор (`binder.get()`) разрешён только в модуле (composition root).
  - Классы бизнес‑логики получают зависимости только через конструктор.
  - `expects` — Fail-Fast проверка наличия необходимых зависимостей от родителя.

- **Управление временем жизни (Retention Policy)**:
  - **RouteBound** — Реализуется через `RouteObserver` в `ModuleScope`. Модуль живёт, пока его роут в стеке.
  - **KeepAlive** — Управление через флаг `disposeModule` (или сохранение контроллера выше по дереву).
  - **Strict** — Уничтожение при unmount виджета `ModuleScope`.

- **Observability (Наблюдаемость)**:
  - **Interceptors** (`ModuleInterceptor`) — Глобальные хуки на `onInit`, `onLoaded`, `onError`, `onDispose`.
  - **Graphviz Export** — Визуализация связей модулей через CLI.

---

## Популярные подходы к модульности в сообществе Dart/Flutter

### 1. Monorepo + package‑per‑feature (melos)

- **Суть**:
  - Разделение кода на отдельные Dart‑пакеты: `feature_auth`, `feature_profile` и т.д.
  - Управление через `melos`.
- **Плюсы**:
  - Явные границы ответственности (compile-time).
- **Минусы**:
  - Нет runtime-модели инициализации и lifetime.
  - "Initialization Hell" решается вручную в `main()`.

### 2. Feature‑first структура в одном пакете

- **Суть**:
  - Папки `lib/features/...` + Clean Architecture.
- **Плюсы**:
  - Простота навигации.
- **Минусы**:
  - Модульность на уровне соглашений, нет изоляции зависимостей.

### 3. flutter_modular

- **Суть**:
  - `Module` с `binds` и `routes`. Дерево модулей.
- **Плюсы**:
  - Удобная связка модульности и роутинга.
- **Минусы**:
  - Жесткая привязка к собственному роутеру. Сложная миграция.

### 4. GetX / Provider / Riverpod / BLoC

- **Суть**:
  - Модульность через DI-контейнеры или поддеревья виджетов.
- **Плюсы**:
  - Быстрый старт, декларативность.
- **Минусы**:
  - Неявный lifetime (завязан на виджеты).
  - Сложные цепочки асинхронной инициализации (особенно в BLoC/Riverpod).

---

## Сравнительный анализ подходов

В таблице ниже приведено сравнение нашего фреймворка (Modularity) с популярными архитектурными подходами:

| Критерий | Modularity (Наш) | Flutter Modular | Melos / Feature Packages | Provider / Riverpod / BLoC |
| :--- | :--- | :--- | :--- | :--- |
| **Определение модуля** | Pure Dart класс (Contracts) + State Machine | Класс с роутами и биндами | Отдельный Dart package | Папка / набор провайдеров |
| **Инициализация** | Автоматическая (DAG), `onInit` после импортов | При навигации / старте модуля | Ручная (`main.dart`) | Ленивая / при маунте виджета |
| **Управление зависимостями** | Явные `imports` + `expects` + `exports` | Дерево модулей, глобальный контейнер | `pubspec.yaml` | `ProviderScope` / `MultiBlocProvider` |
| **Жизненный цикл (Lifetime)** | `ModuleStatus` + `Retention Policy` (RouteBound) | Привязан к роутеру Modular | Не определен (обычно singleton) | Привязан к Widget Tree |
| **Связь с роутингом** | Слабая (через адаптеры и конфиги) | Сильная (роутер — часть фреймворка) | Отсутствует | Косвенная (через контекст) |
| **Тестируемость** | `testModule` (Unit), подмена `Binder` | Integration тесты | Стандартные тесты пакетов | Widget тесты (`pumpWidget`) |
| **Параметризация** | Строгий `Configurable<T>` | Аргументы роута (`r.args`) | Конструкторы | Аргументы виджетов / Family провайдеры |
| **Наблюдаемость** | Встроена (`Interceptors`, Graphviz CLI) | Логирование | Отсутствует | DevTools конкретного стейт-менеджера |

---

## Выводы и позиционирование

Фреймворк реализует подход **строгого разделения контрактов и реализации**.

- **Contracts-first**: Позволяет писать модули, не завися от деталей реализации ядра.
- **Explicit Lifecycle**: Формализованные статусы и перехватчики (`Interceptors`) обеспечивают полный контроль над происходящим в приложении.
- **Tooling**: CLI и тестовые утилиты делают работу с модулями прозрачной.

Это решение ориентировано на **Enterprise-системы**, где важны предсказуемость инициализации, строгие границы и наблюдаемость, даже ценой небольшого boilerplate (описание `imports`/`exports`).
